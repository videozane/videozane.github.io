<!DOCTYPE html>
<html>
<head>
    <title>Project 3: Image Warping and Mosaicing</title>
    <link rel="stylesheet" href="../stylesheet.css">
</head>
<body>

<script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        }
      };
</script>
<script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>

<div class="header-card">
    <div class="header-left">
        <h1>Project 3: Image Warping and Mosaicing</h1>
    </div>
    <div class="header-right">
        <span class="tag">CS180</span>
        <span class="tag">Due Oct 8, 2025 at 11:59 PM</span>
        <span class="tag">Zane Danton</span>
    </div>
</div>

<div class="base_page">
    <h3>A.1: Shoot and digitize pictures</h1>
    <p>
        I took three sets of photos: a view from the Music Library, Wurster stairs, and Wurster Hall.
    </p>

    <p>
        For each set, I tried to maintain an overlap region, as well as rotate my camera solely about the actual camera lens to prevent a shift in center of projection. 
    </p>

    <h4>Set 1: Music Library View</h4>
    <div class="item-row" style="align-self: center; justify-content: center;">
          <div class="image-col">
            <img src="./images/set1/L1.jpg" alt="Music Library 1">
          </div>
          <div class="image-col">
            <img src="./images/set1/L2.jpg" alt="Music Library 2">
          </div>
    </div>

    <h4>Set 2: Wurster Hall</h4>
    <div class="item-row" style="align-self: center; justify-content: center;">
          <div class="image-col">
            <img src="./images/set2/R1.jpg" alt="Wurster Hall 1">
          </div>
          <div class="image-col">
            <img src="./images/set2/R2.jpg" alt="Wurster Hall 2">
          </div>
    </div>

    <h4>Set 3: Wurster Stairs</h4>
    <div class="item-row" style="align-self: center; justify-content: center;">
          <div class="image-col">
            <img src="./images/set3/L1.jpg" alt="Wurster Stairs 1">
          </div>
          <div class="image-col">
            <img src="./images/set3/L2.jpg" alt="Wurster Stairs 2">
          </div>
    </div>
</div>

<br>

<div class="base_page">
  <h3>A.2: Implement computeH(im1_pts,im2_pts)</h3>
  <h4>Derive Point Correspondence</h4>
  <p> 
    Begining with the homography equation from lecture, we have:
  </p>
  <br>
  $$
  \begin{bmatrix} x'w \\ y'w \\ w \end{bmatrix} =
  \begin{bmatrix} h_{11} & h_{12} & h_{13} \\ h_{21} & h_{22} & h_{23} \\ h_{31} & h_{32} & h_{33} \end{bmatrix}
  \begin{bmatrix} x \\ y \\ 1 \end{bmatrix}
  $$
  <br>
  <p>$w$ is the homogenous scaling factor.
    If we multiply two right side matrices, we get the three equations:
  </p>
  <br>
  $$
  \begin{align*}
      x'w &= h_{11}x + h_{12}y + h_{13} \\
      y'w &= h_{21}x + h_{22}y + h_{23} \\
      w &= h_{31}x + h_{32}y + h_{33}
  \end{align*}
  $$
  <br>
  <p>
    We know from lecture that we can set $h_{33} = 1$ to reduce the number of unknowns from 9 to 8, since the homography is defined up to scale. This gives us:
  </p>
  <br>
  $$
  w = h_{31}x + h_{32}y + 1
  $$
  <br>
  <p>which we can substitue into the other equations to eliminate $w$:</p>
<br>
  \begin{align*}
      x'(h_{31}x + h_{32}y + 1) &= h_{11}x + h_{12}y + h_{13} \\
      y'(h_{31}x + h_{32}y + 1) &= h_{21}x + h_{22}y + h_{23}
  \end{align*}
<br>
  <p>
    If we isolate $x'$ and $y'$, we directly define the rows of matrix $A$ and vector $b$ for a point correspondence:
  </p>
  <br>
  \begin{align*}
      h_{11}x + h_{12}y + h_{13} - h_{31}x x' - h_{32}y x' &= x' \\
      h_{21}x + h_{22}y + h_{23} - h_{31}x y' - h_{32}y y' &= y'
  \end{align*}
  <br>
  <h4>Creating the homography </h4>
  <p>
    The vector of our 8 unknown degrees of freedom is:
  </p>
  <br>
  $$
  h = \begin{bmatrix} h_{11} & h_{12} & h_{13} & h_{21} & h_{22} & h_{23} & h_{31} & h_{32} \end{bmatrix}^T
  $$
  <br>
  <p>From above, the system for a single point correspondence is:</p>
  <br>
  $$
  \begin{bmatrix}
  x & y & 1 & 0 & 0 & 0 & -xx' & -yx' \\
  0 & 0 & 0 & x & y & 1 & -xy' & -yy'
  \end{bmatrix}
  \begin{bmatrix}
  h_{11} \\ h_{12} \\ h_{13} \\ h_{21} \\ h_{22} \\ h_{23} \\ h_{31} \\ h_{32}
  \end{bmatrix}
  =
  \begin{bmatrix}
  x' \\ y'
  \end{bmatrix}
  $$
  <br>
  <p>
    We can then stack these rows in the left and resulting matrices for additional point correspondences. When this uses more than four point correspondences, we can solve the resulting overdetermined system with least squares to find the best fitting homography.
  </p>
    <hr class="custom">
  <p>
        As an example for set 3, I defined 10 point correspondences as such (shown with a line between corresponding point), resulting in the $H$ matrix:
    </p>
    <br>
    $$
      H = \begin{bmatrix} 2.069 & 0.011 & −647.7 \\ 0.361 & 1.717 & −190.3 \\ 0.001 & -0.00002 & 1.0 \end{bmatrix}
    $$

    <img src="./images/set3/point_correspondences.jpg" alt="Wurster Stairs Points" style="max-width: 100%; align-self: center;">
</div>
<br>
<div class="base_page">
  <h3>A.3: Warp the images</h3>
    <p>
        For this section we implemented our two warping functions as: 
    </p>
    <pre><code class="language-javascript">imwarped_nn = warpImageNearestNeighbor(im,H)
imwarped_bil = warpImageBilinear(im,H)</code></pre>

    <p>
        To prove the validity of the implementations, we can rectify example images. <br><br>The below comparisons show the original image, the $H$ matrix, and the result using both functions. Finally, there is a pixel-wise comparison noting any differences. I chose not to crop in the images to show warping around the target.
    </p>
        <img src="./images/rectify/square3_rectification_visualization.jpg" alt="Rec3" style="max-width: 100%; align-self: center;">
            <hr class="custom">
        <img src="./images/rectify/square2_rectification_visualization.jpg" alt="Rec1" style="max-width: 100%; align-self: center;">
    <p>
        Interestingly, my bilinear implementation ran faster, despite being more complex. For example, the time is ~6.59s vs ~5.98s between nearest neighbor and bilinear in the second rectification. I believe this could be due to multiple image array accesses which take longer than value calculations on my personal machine. The bilinear warp seems slightly blurrier than the neighrest neighbor, which aligns with the idea of averaging neighbors.
        <br><br>Most of the pixel differences are around changes in edges/features in the image, which the bilinear would blur slightly. 
    </p>
</div>

<br>

<div class="base_page">
  <h3>A.4: Blend the Images into a Mosaic</h3>
  <p>
    In this section we actually create our mosaics. 
    <br><br>I chose the one shot procedure, where, per the spec, I first determined the size of final mosaic and inverse warped (preventing holes) all the images into that size using the homographies computed relative to the center image. 
    <br><br>In order to prevent a overlapping seam, I implemented two-band blending. I found the overlapping region of the two images and used the distance transform <b>scipy.ndimage.distance_transform_edt</b> to find the distance of each pixel to the nearest zero pixel. I then binarized this with a threshold of 0.5 to create a hard seam, which I passed into the pyramid blending functions we implemented in project 2. The low frequency portions of the images used a Gaussian blur to softly blend the images together, while the high frequencies used the binary mask to merge. My results are as such, shown with the bilinear warping strategy in the mosaic:
  </p>

  <h4>Set 1: Music Library View</h4>
    <div class="item-row" style="align-self: center; justify-content: center; border-bottom: 0px; margin-bottom: -5px;">
          <div class="image-col">
            <img src="./images/set1/L1.jpg" alt="Music Library 1">
          </div>
          <div class="image-col">
            <img src="./images/set1/L2.jpg" alt="Music Library 2">
          </div>
    </div>
    <img src="./images/set1/mosaic_image_bilinear.png" alt="Music Library 2" style="scale: 80%; max-width: 100%; align-self: center;">
    <hr class="custom">

    <h4>Set 2: Wurster Hall</h4>
    <div class="item-row" style="align-self: center; justify-content: center; border-bottom: 0px; margin-bottom: -5px;">
          <div class="image-col">
            <img src="./images/set2/R1.jpg" alt="Music Library 1">
          </div>
          <div class="image-col">
            <img src="./images/set2/R2.jpg" alt="Music Library 2">
          </div>
    </div>
    <img src="./images/set2/mosaic_image_bilinear.png" alt="Music Library 2" style="scale: 80%; max-width: 100%; align-self: center;">
    <hr class="custom">

    <h4>Set 3: Wurster Stairs</h4>
    <div class="item-row" style="align-self: center; justify-content: center; border-bottom: 0px; margin-bottom: -5px;">
          <div class="image-col">
            <img src="./images/set3/L1.jpg" alt="Music Library 1">
          </div>
          <div class="image-col">
            <img src="./images/set3/L2.jpg" alt="Music Library 2">
          </div>
    </div>
    <img src="./images/set3/mosaic_image_bilinear.png" alt="Music Library 2" style="scale: 80%; max-width: 100%; align-self: center;">
    <hr class="custom">

    
    <p>
      To compare the output with and without blending, I also created mosaics using simple overlaying, resulting in a hard seam in the overlapping region.
    </p>

    <div class="item-row" style="align-self: center; justify-content: center; border-bottom: 0px; margin-bottom: -5px;">
          <div class="image-col" style="max-width: 700px;">
            <img src="./images/set1/example_nonblend_bilinear.png">
          </div>
          <div class="image-col" style="max-width: 700px;">
            <img src="./images/set1/mosaic_image_bilinear.png">
          </div>
    </div>
    <hr class="custom">
    <div class="item-row" style="align-self: center; justify-content: center; border-bottom: 0px; margin-bottom: -5px;">
          <div class="image-col" style="max-width: 700px;">
            <img src="./images/set2/example_nonblend_bilinear.png">
          </div>
          <div class="image-col" style="max-width: 700px;">
            <img src="./images/set2/mosaic_image_bilinear.png">
          </div>
    </div>
    <hr class="custom">
    <div class="item-row" style="align-self: center; justify-content: center; border-bottom: 0px; margin-bottom: -5px;">
          <div class="image-col" style="max-width: 700px;">
            <img src="./images/set3/example_nonblend_bilinear.png">
          </div>
          <div class="image-col" style="max-width: 700px;">
            <img src="./images/set3/mosaic_image_bilinear.png">
          </div>
    </div>
  </div>

  <br>
  <div class="base_page">
  <h3>Part B: Automatic Stitching</h3>
    <p>
        The second part of the project was to build a fully automatic pipeline to replace the manual selection of correspondence points. This involved implementing a series of algorithms to detect, describe, and robustly match features between images.
    </p>
    <hr class="custom">
    <h4>B.1 & B.2: Harris Corners and ANMS</h4>
    <p>
        The first step is to automatically find distinctive feature points. We use Harris Corner detection, which identifies points where image intensity changes significantly in multiple directions. However, this initial detection yields thousands of points, many of them clustered together.
    </p>
    <p>
        To get a smaller and more spatially diverse set of features, we apply Adaptive Non-Maximal Suppression (ANMS). For each corner, ANMS calculates the minimum distance to another corner that is significantly stronger. By selecting the 500 points with the largest suppression radii, we ensure our final feature set is both strong and well-distributed across the image, which is crucial for a stable homography calculation.
    </p>
    <img src="./images/set1/auto/anms_corners.jpg" alt="ANMS Corners" style="max-width: 100%; align-self: center;">
    <hr class="custom">
    <h4>B.3: Feature Descriptor Extraction</h4>
    <p>
        Once we have our keypoints, we extract a feature descriptor for each one to allow us to compare points between images. We extract a large 40x40 window around each corner candidate, apply a Gaussian blur to make it resistant to noise, and downsample it to a standard 8x8 patch. Finally, we normalize this patch to have a mean of 0 and a standard deviation of 1. This normalization makes the descriptor invariant to changes in brightness and contrast.
    </p>
    <img src="./images/set1/auto/sample_patches.jpg" alt="Sample Patches" style="max-width: 100%; align-self: center;">
    <hr class="custom">
    <h4>B.4: Feature Matching</h4>
    <p>
        With descriptors for every point in both images, we can now find matches. We use the ratio test, a robust method proposed by Lowe in the project reference paper to calculate patch similarity. For each descriptor in the first image, we find its two nearest neighbors in the second image. A match is considered reliable only if the distance to the best match ($d_1$) is significantly smaller than the distance to the second-best match ($d_2$). We keep a match if the ratio $d_1/d_2$ is below a certain threshold. As shown in the paper's ROC curve, a threshold around 0.8 provides a good balance, eliminating most false positives while retaining a high number of true positives.
    </p>
    <div class="item-row" style="align-self: center; justify-content: center;">
          <div class="image-col">
            <img src="./feature_match_paper.png" alt="Paper Graphs">
          </div>
          <div class="image-col">
            <img src="./images/set1/auto/matched_patches.jpg" alt="Matched Patches">
          </div>
    </div>
    <hr class="custom">
    <h4>B.5: RANSAC for Robust Homography</h4>
    <p>
        Even with the ratio test, the set of matches contains incorrect matches. To compute an accurate homography, we use RANSAC (Random Sample Consensus). RANSAC is an iterative algorithm that finds the best transformation by building a consensus from the data.
    </p>
    <p>
        In each iteration, it randomly selects a sample of 4 correspondence pairs, computes a candidate homography from them, and then counts how many of the other correspondences are consistent with this $H$ (the "inliers"). After thousands of iterations, the algorithm chooses the homography that had the largest set of inliers. For a final, more accurate result, we re-compute the homography one last time using the total set of inliers. The image below shows an example inlier set found by RANSAC.
    </p>
    <img src="./images/set1/auto/inlier_matches.jpg" alt="Inlier Matches" style="max-width: 100%; align-self: center;">
    <hr class="custom">
    <h4>Final Automatic Mosaics</h4>
    <p>
        Using the homography computed using RANSAC, we can warp and blend the images automatically. Below is a comparison of the manually stitched results and the automatic results for each of the three sets.
    </p>

    <h5>Set 1: Music Library View (Manual vs. Auto)</h5>
    <div class="item-row" style="align-self: center; justify-content: center;">
          <div class="image-col">
            <img src="./images/set1/mosaic_image_bilinear.png" alt="Manual Set 1">
          </div>
          <div class="image-col">
            <img src="./images/set1/auto/mosaic_bilinear_auto.png" alt="Auto Set 1">
          </div>
    </div>
    <hr class="custom">

    <h5>Set 2: Wurster Hall (Manual vs. Auto)</h5>
    <div class="item-row" style="align-self: center; justify-content: center;">
          <div class="image-col">
            <img src="./images/set2/mosaic_image_bilinear.png" alt="Manual Set 2">
          </div>
          <div class="image-col">
            <img src="./images/set2/auto/mosaic_bilinear_auto.png" alt="Auto Set 2">
          </div>
    </div>
    <hr class="custom">
    
    <h5>Set 3: Wurster Stairs (Manual vs. Auto)</h5>
    <div class="item-row" style="align-self: center; justify-content: center;">
          <div class="image-col">
            <img src="./images/set3/mosaic_image_bilinear.png" alt="Manual Set 3">
          </div>
          <div class="image-col">
            <img src="./images/set3/auto/mosaic_bilinear_auto.png" alt="Auto Set 3">
          </div>
    </div>
</div>

<br>
<a href="../home.html">&larr; Back to Home</a>
</body>
</html>